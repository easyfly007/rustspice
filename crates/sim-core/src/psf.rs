use crate::result_store::RunResult;
use std::fs;
use std::path::Path;

const VERSION: &str = env!("CARGO_PKG_VERSION");

/// Write a single-point analysis result (OP or final TRAN state) to PSF text format.
pub fn write_psf_text(run: &RunResult, path: &Path, precision: usize) -> std::io::Result<()> {
    let mut out = String::new();

    // Header
    out.push_str("PSF_TEXT\n");
    out.push_str(&format!("# Generated by MySpice v{}\n", VERSION));
    out.push_str(&format!("# Date: {}\n", chrono_lite_now()));
    out.push('\n');

    // Analysis info section
    out.push_str("[Header]\n");
    out.push_str(&format!("analysis = {:?}\n", run.analysis));
    out.push_str(&format!("status = {:?}\n", run.status));
    out.push_str(&format!("iterations = {}\n", run.iterations));
    out.push('\n');

    // Signal names section
    out.push_str("[Signals]\n");
    for name in &run.node_names {
        out.push_str(&format!("V({})\n", name));
    }
    out.push('\n');

    // Values section with aligned columns
    out.push_str("[Values]\n");
    let max_name_len = run.node_names.iter().map(|n| n.len() + 3).max().unwrap_or(4);
    for (idx, value) in run.solution.iter().enumerate() {
        let name = run
            .node_names
            .get(idx)
            .cloned()
            .unwrap_or_else(|| format!("n{}", idx));
        let signal = format!("V({})", name);
        out.push_str(&format!("{:width$}  {:.*e}\n", signal, precision, value, width = max_name_len));
    }

    fs::write(path, out)
}

/// Write DC sweep results to PSF text format.
pub fn write_psf_sweep(
    source: &str,
    sweep_values: &[f64],
    node_names: &[String],
    sweep_results: &[Vec<f64>],
    path: &Path,
    precision: usize,
) -> std::io::Result<()> {
    let mut out = String::new();

    // Header
    out.push_str("PSF_TEXT\n");
    out.push_str(&format!("# Generated by MySpice v{}\n", VERSION));
    out.push_str(&format!("# Date: {}\n", chrono_lite_now()));
    out.push('\n');

    // Sweep info section
    out.push_str("[Sweep]\n");
    out.push_str(&format!("source = {}\n", source));
    out.push_str(&format!("points = {}\n", sweep_values.len()));
    out.push('\n');

    // Signal names section
    out.push_str("[Signals]\n");
    out.push_str(&format!("{}\n", source));
    for name in node_names {
        out.push_str(&format!("V({})\n", name));
    }
    out.push('\n');

    // Data section with columnar format
    out.push_str("[Data]\n");

    // Header row
    let col_width = precision + 8; // space for sign, decimal, exponent
    out.push_str(&format!("{:>width$}", source, width = col_width));
    for name in node_names {
        out.push_str(&format!("  {:>width$}", format!("V({})", name), width = col_width));
    }
    out.push('\n');

    // Data rows - only output values for nodes in node_names (same as header)
    for (i, sweep_val) in sweep_values.iter().enumerate() {
        out.push_str(&format!("{:>width$.prec$e}", sweep_val, width = col_width, prec = precision));
        if let Some(solution) = sweep_results.get(i) {
            for (node_idx, _name) in node_names.iter().enumerate() {
                let val = solution.get(node_idx).copied().unwrap_or(0.0);
                out.push_str(&format!("  {:>width$.prec$e}", val, width = col_width, prec = precision));
            }
        }
        out.push('\n');
    }

    fs::write(path, out)
}

/// Write AC analysis results to PSF text format.
pub fn write_psf_ac(
    frequencies: &[f64],
    node_names: &[String],
    ac_solutions: &[Vec<(f64, f64)>],
    path: &Path,
    precision: usize,
) -> std::io::Result<()> {
    let mut out = String::new();

    // Header
    out.push_str("PSF_TEXT\n");
    out.push_str(&format!("# Generated by MySpice v{}\n", VERSION));
    out.push_str(&format!("# Date: {}\n", chrono_lite_now()));
    out.push('\n');

    // AC analysis info section
    out.push_str("[AC Analysis]\n");
    out.push_str("type = frequency_response\n");
    out.push_str(&format!("points = {}\n", frequencies.len()));
    out.push('\n');

    // Signal names section
    out.push_str("[Signals]\n");
    out.push_str("frequency\n");
    for name in node_names {
        if name != "0" {
            out.push_str(&format!("VM({})\n", name));
            out.push_str(&format!("VP({})\n", name));
        }
    }
    out.push('\n');

    // Data section with columnar format
    out.push_str("[Data]\n");

    // Header row
    let col_width = precision + 10;
    out.push_str(&format!("{:>width$}", "frequency", width = col_width));
    for name in node_names {
        if name != "0" {
            out.push_str(&format!("  {:>width$}", format!("VM({})", name), width = col_width));
            out.push_str(&format!("  {:>width$}", format!("VP({})", name), width = col_width));
        }
    }
    out.push('\n');

    // Data rows
    for (i, freq) in frequencies.iter().enumerate() {
        out.push_str(&format!("{:>width$.prec$e}", freq, width = col_width, prec = precision));
        if let Some(solution) = ac_solutions.get(i) {
            for (node_idx, name) in node_names.iter().enumerate() {
                if name != "0" {
                    if let Some((mag_db, phase_deg)) = solution.get(node_idx) {
                        out.push_str(&format!("  {:>width$.prec$e}", mag_db, width = col_width, prec = precision));
                        out.push_str(&format!("  {:>width$.prec$e}", phase_deg, width = col_width, prec = precision));
                    }
                }
            }
        }
        out.push('\n');
    }

    fs::write(path, out)
}

/// Write TRAN analysis waveform results to PSF text format.
pub fn write_psf_tran(
    times: &[f64],
    node_names: &[String],
    solutions: &[Vec<f64>],
    path: &Path,
    precision: usize,
) -> std::io::Result<()> {
    let mut out = String::new();

    // Header
    out.push_str("PSF_TEXT\n");
    out.push_str(&format!("# Generated by MySpice v{}\n", VERSION));
    out.push_str(&format!("# Date: {}\n", chrono_lite_now()));
    out.push('\n');

    // TRAN info section
    out.push_str("[Transient Analysis]\n");
    out.push_str(&format!("points = {}\n", times.len()));
    if let (Some(&tstart), Some(&tstop)) = (times.first(), times.last()) {
        out.push_str(&format!("tstart = {:e}\n", tstart));
        out.push_str(&format!("tstop = {:e}\n", tstop));
    }
    out.push('\n');

    // Signal names section
    out.push_str("[Signals]\n");
    out.push_str("time\n");
    for name in node_names {
        if name != "0" {
            out.push_str(&format!("V({})\n", name));
        }
    }
    out.push('\n');

    // Data section with columnar format
    out.push_str("[Data]\n");

    // Header row
    let col_width = precision + 8;
    out.push_str(&format!("{:>width$}", "time", width = col_width));
    for name in node_names {
        if name != "0" {
            out.push_str(&format!("  {:>width$}", format!("V({})", name), width = col_width));
        }
    }
    out.push('\n');

    // Data rows
    for (i, time) in times.iter().enumerate() {
        out.push_str(&format!("{:>width$.prec$e}", time, width = col_width, prec = precision));
        if let Some(solution) = solutions.get(i) {
            for (node_idx, name) in node_names.iter().enumerate() {
                if name != "0" {
                    let val = solution.get(node_idx).copied().unwrap_or(0.0);
                    out.push_str(&format!("  {:>width$.prec$e}", val, width = col_width, prec = precision));
                }
            }
        }
        out.push('\n');
    }

    fs::write(path, out)
}

/// Simple timestamp function without external dependency.
fn chrono_lite_now() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};

    let duration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    let secs = duration.as_secs();

    // Convert to date/time components (simplified, UTC)
    let days_since_epoch = secs / 86400;
    let time_of_day = secs % 86400;

    let hours = time_of_day / 3600;
    let minutes = (time_of_day % 3600) / 60;
    let seconds = time_of_day % 60;

    // Calculate year, month, day from days since epoch (1970-01-01)
    let (year, month, day) = days_to_ymd(days_since_epoch as i64);

    format!(
        "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z",
        year, month, day, hours, minutes, seconds
    )
}

/// Convert days since Unix epoch to year/month/day.
fn days_to_ymd(days: i64) -> (i64, u32, u32) {
    // Simplified calculation
    let mut remaining = days;
    let mut year = 1970i64;

    loop {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if remaining < days_in_year {
            break;
        }
        remaining -= days_in_year;
        year += 1;
    }

    let leap = is_leap_year(year);
    let days_in_months: [i64; 12] = if leap {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };

    let mut month = 1u32;
    for &days_in_month in &days_in_months {
        if remaining < days_in_month {
            break;
        }
        remaining -= days_in_month;
        month += 1;
    }

    let day = remaining as u32 + 1;
    (year, month, day)
}

fn is_leap_year(year: i64) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}
